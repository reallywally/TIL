# 자잘한 메모

1개의 md파일로 작성할 만큼 내용이 크지는 않지만 내용상 기억하고 싶은 것을 작성한다.

## 내용들

1. pandas cross join

    결과적으로 하고 싶었던 내용을 정리하면 다음과 같다.

    | 이름 | 년도 | 직업|
    |-|-|-|
    | A | 2022 | 개발자 |
    | A | 2025 | 기획자 |
    | B | 2020 | 디자이너 |
    | B | 2024 | 디자이너 |

    위와 같은 데이터가 있는데 조회 조건을 날짜로 2020 ~ 2026년을 조회하면

    | 이름 | 년도 | 직업|
    |-|-|-|
    | A | 2022 | 개발자 |
    | A | 2023 | 개발자 |
    | A | 2024 | 개발자 |
    | A | 2025 | 기획자 |
    | A | 2026 | 기획자 |
    | B | 2020 | 디자이너 |
    | B | 2021 | 디자이너 |
    | B | 2022 | 디자이너 |
    | B | 2023 | 디자이너 |
    | B | 2024 | 디자이너 |
    | B | 2025 | 디자이너 |
    | B | 2026 | 디자이너 |

    이렇게 년도에 비어있는 데이터를 채우고 싶었다. 그래서 이름별 전체 년도 데이터프레임을 만들고 left merge하면 쉽게 해결 될거라 생각했다. 하지만 생각보다 이름별 전체 년도 데이터프레임을 만드는 작업이 어려웠다.  
    정확하게는 어려웠다기 보단 처음 해결 방법을 잘못 생각했었다. 처음 생각한 방법은 1)조회한 데이터프레임에 년도를 추가하고 2) 날짜만있는 데이터프레임을 만들고 3) 두개는 merge하는 방식이었다.  
    결과적으로 처음 생각한 방식은 올바른 해결 방법이 아니었고 GPT랑 클로드씨의 자문을 구한 결과 날짜만 있는 데이터프레임과 조회 결과 데이터프레임을 cross 조인하면 되었다.

2. pandas groupby

    생성된 df를 groupby 하여 bfill()로 채워야하는 상황이었다. 그런데 정상적으로 데이터는 있었는데 groupby만 하면 데이터가 이상해졌다.
    알고보니 groupby 함수는 기본적으로 dropna=True로 설정되어져 있었고, 그룹화 기준 컬럼에 None이 있어 그룹화 결과에서 아예 제외되었다. SQL은 null이 있어도 묶어주기 때문에 동일하게 생각한 부분이 큰 실수였다.
