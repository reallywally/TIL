# 파이썬 가비지 컬렉션

## 가비지 컬렉션이란?

프로그램이 더 이상하지 않는 메모리를 자동으로 정리하는 메커니즘이다.

## 왜 가비지 컬렉션이 필요할까?

만약 가비지 컬렉션이 없다면 여러 프로그램이 실행될수록 메모리 사용량이 계속 증가하고, 결국 시스템에 메모리가 부족해져서 프로그램이 죽는다.
그리고 프로그램이 죽는걸 방지하기 위해 개발자가 수동으로 모든 메모리를 관리해야하는데 이게 쉽지 않다.

## 파이썬의 가비지 컬렉션 방식

파이썬은 두 가지 주요 방식으로 메모리를 관리한다. JVM은 tracing garbage collection 이라는 방법을 사용하는건 참고로 알아두자.

### 1.레퍼런스 카운팅(Reference Counting)

가장 기본적인 방식으로, 객체를 참조하는 변수의 개수를 기준으로 메모리에서 삭제하는 방법이다.

```python
import sys

# 객체 생성
my_list = [1, 2, 3]
print(f"레퍼런스 카운트: {sys.getrefcount(my_list) - 1}")  # -1은 getrefcount 자체 참조 제외

# 새로운 참조 생성
another_ref = my_list
print(f"레퍼런스 카운트: {sys.getrefcount(my_list) - 1}")  # 카운트 증가

# 참조 제거
del another_ref
print(f"레퍼런스 카운트: {sys.getrefcount(my_list) - 1}")  # 카운트 감소
```

그럼 레퍼런스 카운팅은 예시 코드와 같이 del로 직접 지워야지만 삭제가 될까? 그건 아니다.
핵심은 **레퍼런스 카운트가 0이 되는 즉시** 자동으로 객체를 삭제한다는 것이다.
자동으로 삭제되는 주요 상황은 다음과 같다.

- 지역 변수가 스코프를 벗어날 때
- 변수에 새로운 값을 할당할 때
- 리스트, 딕셔너리 등에서 항목을 제거할 때
- 반복문에서 임시 변수가 새 값으로 바뀔 때

#### 장점

레퍼런스 카운트가 0이되면 즉시 메모리에서 해제가 된다. 덕분에 코드만 봐도 언제 삭제가 될지 예측이 가능하고 수동으로 메모리 관리를 하지 않아도 된다.

#### 단점

레퍼런스 카운트가 0이면 해지 된다는 말은 다시말해 0이 되지 않으면 삭제가 안된다는 말이다.
즉, 순환 참조가 되면 절대로 메모리에서 삭제되지 않는다.

#### 순환 참조란

아래 코드와 같이 2개의 다른 변수끼리 서로를 참조하는 경우이다.

```python
class Node:
    def __init__(self, name):
        self.name = name
        self.ref = None

# 두 노드 생성
n1 = Node("n1")
n2 = Node("n2")

# 순환 참조
n1.ref = n2
n2.ref = n1
```

### 2. 사이클릭 가비지 컬렉션(Cyclic Garbage Collection)

앞서 설명한 레퍼런스 카운팅은 순환 참조인 메모리를 지우지 못하는 문제가 있다. 그리고 이를 보완하기 위해 사이클릭 가비지 컬렉션 방식도 이용한다.

#### 동작 원리

먼저 **세대(generation)** 라는 개념을 알아야 한다. 파이썬의 GC(Garbage Collection)는 성능을 위해 **세대(generation)** 개념을 사용하는데 내용은 다음과 같다.

- 0세대: 새로 생성된 객체
- 1세대: 한 번 GC를 통과한 객체
- 2세대: 여러 번 GC를 통과한 장수 객체

파이썬은 "대부분의 객체는 금방 필요 없어지고, 오래 살아남는 객체는 계속 살아남는다"라는 경험적 사실을 기반으로 이 구조를 선택했다.

다시 동작 원리를 정리하면 **참조 그래프(reference graph)**를 기반으로 아래와 같은 순서로 동작하여 메모리를 해제한다.

1. 각 세대에 있는 객체들 중 컨테이너 타입(리스트, 딕셔너리, 사용자 정의 객체 등)을 추적
2. 참조 관계를 따라가면서 외부에서 접근할 수 없는 객체 집합을 찾기
3. 이 집합 내부에서 순환 참조로만 연결된 객체들을 수집 대상으로 판정
4. 참조 카운트를 인위적으로 조정(refcount–)하여 0이 된 객체를 해제

사이클릭 가비지 컬렉션에 대한 개념이 어렵다면 순환 참조 때문에 안 없어지는 객체들을 찾아서 없애주는 청소부라고 이해하자.

## 가지비 컬렉션 오버헤드

사이클릭 가비지 컬렉션이 레퍼런스 카운팅의 단점을 보완하여 좋기는 하지만 2가지 상황으로 오버헤드가 발생한다.

### 1. 주기적 스캔 비용

사이클릭 가비지 컬렉션이 참조 그래프 기반으로 메모리를 해제한다고 하였다. 즉, 객체 수가 많을수록 탐색 비용도 커진다.

### 2. 캐시/버퍼 성능 저하

역시 참조 그래프를 순회하기 때문에 CPU 캐시 친화적이지 못한 랜덤 접근이 발생한다.
특히 메모리 풀에서 많은 객체를 할당/해제하는 패턴에서 병목의 원인이 될 수 있다.

### 오버헤드를 줄이는 방법

상황에 따라 해결 방법이 달라지기 때문에 깊게 파고들기 보다는 이런 방법들이 있다 정도 까지만 알아두자

#### 1. GC 비활성화 + 수동 실행

특정 상황에서는 GC를 끄고 직접 필요할 때만 실행하는 것이 효율적일 수 있다.(직접 경험한건 아님)

```python
import gc

gc.disable()
# 대규모 객체 생성/삭제 처리
gc.collect()  # 원하는 시점에만 실행
gc.enable()
```

#### 2. Threshold 튜닝

#### 3. 객체 재사용
