# 파이썬 가비지 컬렉션

## 가비지 컬렉션이란?

프로그램이 더 이상하지 않는 메모리를 자동으로 정리하는 메커니즘이다.

## 왜 가비지 컬렉션이 필요할까?

만약 가비지 컬렉션이 없다면 여러 프로그램이 실행될수록 메모리 사용량이 계속 증가하고, 결국 시스템에 메모리가 부족해져서 프로그램이 죽는다.
그리고 프로그램이 죽는걸 방지하기 위해 개발자가 수동으로 모든 메모리를 관리해야하는데 이게 쉽지 않다.

## 파이썬의 가비지 컬렉션 방식

파이썬은 두 가지 주요 방식으로 메모리를 관리한다. JVM은 tracing garbage collection 이라는 방법을 사용하는건 참고로 알아두자.

### 1.레퍼런스 카운팅(Reference Counting)

가장 기본적인 방식으로, 객체를 참조하는 변수의 개수를 기준으로 메모리에서 삭제하는 방법이다.

```python
import sys

# 객체 생성
my_list = [1, 2, 3]
print(f"레퍼런스 카운트: {sys.getrefcount(my_list) - 1}")  # -1은 getrefcount 자체 참조 제외

# 새로운 참조 생성
another_ref = my_list
print(f"레퍼런스 카운트: {sys.getrefcount(my_list) - 1}")  # 카운트 증가

# 참조 제거
del another_ref
print(f"레퍼런스 카운트: {sys.getrefcount(my_list) - 1}")  # 카운트 감소
```

그럼 레퍼런스 카운팅은 예시 코드와 같이 del로 직접 지워야지만 삭제가 될까? 그건 아니다.
핵심은 **레퍼런스 카운트가 0이 되는 즉시** 자동으로 객체를 삭제한다는 것이다.
자동으로 삭제되는 주요 상황은 다음과 같다.

- 지역 변수가 스코프를 벗어날 때
- 변수에 새로운 값을 할당할 때
- 리스트, 딕셔너리 등에서 항목을 제거할 때
- 반복문에서 임시 변수가 새 값으로 바뀔 때

#### 장점

레퍼런스 카운트가 0이되면 즉시 메모리에서 해제가 된다. 덕분에 코드만 봐도 언제 삭제가 될지 예측이 가능하고 수동으로 메모리 관리를 하지 않아도 된다.

#### 단점

레퍼런스 카운트가 0이면 해지 된다는 말은 다시말해 0이 되지 않으면 삭제가 안된다는 말이다.
즉, 순환 참조가 되면 절대로 메모리에서 삭제되지 않는다.

#### 순환 참조란

아래 코드와 같이 2개의 다른 변수끼리 서로를 참조하는 경우이다.

```python
class Node:
    def __init__(self, name):
        self.name = name
        self.ref = None

# 두 노드 생성
n1 = Node("n1")
n2 = Node("n2")

# 순환 참조
n1.ref = n2
n2.ref = n1
```

### 2. 사이클릭 가비지 컬렉터(Cyclic Garbage Collector)
