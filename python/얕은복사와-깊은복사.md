# 얕은복사와 깊은복사

## 문제 상황

아래 코드와 같이 학생 정보를 담은 Student 객체를 복사해서 수정했는데, 원본 객체까지 함께 바뀌는 현상이 발생했다.

```python
import copy

class Student:
    def __init__(self, name, scores):
        self.name = name
        self.scores = scores  # 리스트 형태의 점수

    def __repr__(self):
        return f"Student(name={self.name}, scores={self.scores})"

# 원본 객체
s1 = Student("Alice", [90, 85, 88])

# 얕은 복사
s2 = copy.copy(s1)

# 복사본 수정
s2.scores[0] = 0
s2.name = "Tom"

print("원본:", s1)   # Student(name=Alice, scores=[0, 85, 88])
print("복사본:", s2) # Student(name=Tom, scores=[0, 85, 88])
```

복사를 했지만 이상하게 s2.scores 를 바꾸면 s1 의 점수까지 바뀌었는데, s2.name 을 바꿔도 s1 의 이름은 바뀌지 않았다.

## 원인 분석

```copy.copy```()는 객체의 **속성(필드)**을 얕은 복사를 한다. 즉, ```Student``` 객체 자체는 새로 만들어지지만, 그 안의 속성들은 같은 객체를 참조하게 된다.
...