# 얕은복사와 깊은복사

## 문제 상황

아래 코드와 같이 학생 정보를 담은 Student 객체를 복사해서 수정했는데, 원본 객체까지 함께 바뀌는 현상이 발생했다.

```python
import copy

class Student:
    def __init__(self, name, scores):
        self.name = name
        self.scores = scores  # 리스트 형태의 점수

    def __repr__(self):
        return f"Student(name={self.name}, scores={self.scores})"

# 원본 객체
s1 = Student("Alice", [90, 85, 88])

# 얕은 복사
s2 = copy.copy(s1)

# 복사본 수정
s2.scores[0] = 0
s2.name = "Tom"

print("원본:", s1)   # Student(name=Alice, scores=[0, 85, 88])
print("복사본:", s2) # Student(name=Tom, scores=[0, 85, 88])
```

복사를 했지만 이상하게 s2.scores 를 바꾸면 s1 의 점수까지 바뀌었는데, s2.name 을 바꿔도 s1 의 이름은 바뀌지 않았다.

## 원인 분석

```copy.copy```()는 객체의 **속성(필드)** 을 얕은 복사를 한다. 즉, ```Student``` 객체 자체는 새로 만들어지지만, 그 안의 속성들은 같은 객체를 참조하게 된다. 그리고 여기서 핵심은 객체의 불변(Immutable), 가변(Mutable)이다.

## 불변(Immutable) vs 가변(Mutable)

불변, 가변을 테이블로 정리하면 다음과 같다.

|타입|예시|변경 가능 여부|복사 시 동작|
|---|---|---|---|
|불변 객체|int, float, str, tuple| 불가능|값을 바꾸면 새 객체 생성|
|가변 객체|list, dict, set, 사용자 정의 클래스 속성|가능|같은 객체를 공유하면 함께 바뀜|

즉, s2.name = "Tom" 을 실행하면 "Tom" 이라는 새로운 문자열 객체가 생성되어 s2.name 이 그걸 가리키게 된다. 그리고 s1.name 은 여전히 "Alice" 를 가리키므로 원본에는 영향이 없다.  
하지만 s2.scores[0] = 0 은 리스트 내부의 값을 직접 변경하는 것이므로, s1.scores 도 함께 바뀐다. 두 객체가 같은 리스트를 참조 중이기 때문이다.

## 깊은 복사

그래서 scores같은 내부 객체까지 완전히 분리하기 위해서는 ```copy.deepcopy()```를 사용해야 한다.

```python
import copy

s1 = Student("Alice", [90, 85, 88])
s2 = copy.deepcopy(s1)

s2.scores[0] = 0
s2.name = "Tom"

print("원본:", s1)    # Student(name=Alice, scores=[90, 85, 88])
print("복사본:", s2)  # Student(name=Tom, scores=[0, 85, 88])
```

## 실무에서의 교훈

실무에서는 이런 상황이 자주 생긴다. 예를 들어 ORM 엔티티, DTO, 설정 객체 등 데이터를 조회하고 그냥 원본 그대로 사용하다가 어느 의도치 않은 값으로 나오는 경우가 많다. 깊은 복사와 얕은 복사를 이해하고 상황에 따라 객체를 복사하여 사용하자.
